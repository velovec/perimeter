package ru.v0rt3x.perimeter.agent.executor;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.AsyncResult;
import org.springframework.stereotype.Component;
import ru.v0rt3x.perimeter.agent.properties.PerimeterProperties;

import java.util.*;
import java.util.concurrent.Future;
import java.util.regex.Pattern;

@Component
public class ExploitExecutor {

    @Autowired
    private PerimeterProperties perimeterProperties;

    private static final Logger logger = LoggerFactory.getLogger(ExploitExecutor.class);

    @Async
    @SuppressWarnings("unchecked")
    public Future<Map<String, Object>> executeExploit(Map<String, Object> parameters) {
        if (!parameters.containsKey("exploit") || !parameters.containsKey("teams") || !parameters.containsKey("flagPattern"))
            throw new IllegalArgumentException("Invalid execution task");

        Map<String, Object> exploit = (Map<String, Object>) parameters.get("exploit");
        List<Map<String, Object>> teams = (List<Map<String, Object>>) parameters.get("teams");
        Pattern flagPattern = Pattern.compile((String) parameters.get("flagPattern"));
        Map<String, Object> result = new LinkedHashMap<>();

        teams.parallelStream()
            .map(team -> executeExploit(team, flagPattern, exploit))
            .forEach(executionResult -> {
                // TODO: Implement execution result handling
            });

        return new AsyncResult<>(result);
    }

    private ExecutionResult executeExploit(Map<String, Object> team, Pattern flagPattern, Map<String, Object> exploit) {
        logger.info(String.format(
            "Running exploit '%s' (type: %s) for %s (IP: %s)",
            exploit.get("name"), exploit.get("type"), team.get("name"), team.get("ip")
        ));

        // TODO: Implement exploit execution

        return new ExecutionResult();
    }
}
