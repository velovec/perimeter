package ru.v0rt3x.perimeter.executor;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import ru.v0rt3x.perimeter.agent.PerimeterAgentTaskHandler;
import ru.v0rt3x.perimeter.agent.annotation.AgentTaskHandler;
import ru.v0rt3x.perimeter.agent.types.AgentTask;
import ru.v0rt3x.perimeter.executor.properties.PerimeterExecutorProperties;
import ru.v0rt3x.perimeter.executor.utils.ProcessUtils;

import javax.annotation.PostConstruct;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.util.*;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Component
public class ExploitExecutor extends PerimeterAgentTaskHandler {

    @Autowired
    private PerimeterExecutorProperties executorProperties;

    private File tmpDirectory;

    private static final Logger logger = LoggerFactory.getLogger(ExploitExecutor.class);

    private static final Pattern EVENT_PATTERN = Pattern.compile(
        "^(?<level>INFO|WARNING|URGENT)\\{(?<message>[^\\}]+)\\}$"
    );

    public ExploitExecutor() {
        super("executor");
    }

    @PostConstruct
    private void setUpExecutor() {
        tmpDirectory = executorProperties.getTmpDirectory();

        if (!tmpDirectory.exists())
            tmpDirectory.mkdirs();

        if (!tmpDirectory.isDirectory())
            throw new IllegalStateException(String.format(
                "%s is not a directory", tmpDirectory.getAbsolutePath()
            ));
    }

    private File getTempFile(String format, Object... args) {
        return new File(tmpDirectory, String.format(format, args));
    }

    private File writeExploitFile(Map<String, Object> exploit) {
        String exploitFileName = String.format(
            "%s/exploit_%s.%s", exploit.get("id"), exploit.get("id"), ((String) exploit.get("type")).toLowerCase()
        );
        File exploitFile = getTempFile(exploitFileName);

        try (FileWriter writer = new FileWriter(exploitFile)) {
            writer.write(new String(
                Base64.getDecoder().decode((String) exploit.get("script"))
            ));
        } catch (IOException e) {
            logger.error("Unable to write exploit file: {}", e.getMessage());
        }

        return exploitFile;
    }

    private int executeAndWait(String[] command, File workDir, File outputLog, File errorLog) {
        ProcessBuilder processBuilder = new ProcessBuilder(command);

        processBuilder.environment().putAll(System.getenv());
        processBuilder.directory(workDir);

        if (outputLog.exists())
            outputLog.delete();

        if (errorLog.exists())
            errorLog.delete();

        processBuilder.redirectOutput(ProcessBuilder.Redirect.to(outputLog));
        processBuilder.redirectError(ProcessBuilder.Redirect.to(errorLog));

        try {
            Process process = processBuilder.start();

            if (!process.waitFor(executorProperties.getExecutionTimeout(), TimeUnit.MILLISECONDS)) {
                int processId = ProcessUtils.getProcessId(process);
                ProcessUtils.kill(processId, 9);

                process.destroyForcibly().waitFor();

                logger.warn("Exploit PID{} killed by timer", processId);
            }

            return process.exitValue();
        } catch (InterruptedException | IOException e) {
            logger.error("Unable to execute command: {}", e.getMessage());
        }

        return 1;
    }

    private List<String> extractFlags(File logFile, Pattern flagPattern) {
        try {
            return Files.readAllLines(logFile.toPath()).parallelStream()
                .filter(Objects::nonNull)
                .filter(line -> flagPattern.matcher(line).matches())
                .collect(Collectors.toList());
        } catch (IOException e) {
            logger.error("Unable to parse flags: {}", e.getMessage());
        }

        return new ArrayList<>();
    }

    private List<Map<String, String>> extractEvents(File logFile) {
        try {
            return Files.readAllLines(logFile.toPath()).parallelStream()
                .filter(Objects::nonNull)
                .map(EVENT_PATTERN::matcher)
                .filter(Matcher::matches)
                .map(matcher -> {
                    Map<String, String> event = new HashMap<>();

                    event.put("level", matcher.group("level"));
                    event.put("message", matcher.group("message"));

                    return event;
                })
                .collect(Collectors.toList());
        } catch (IOException e) {
            logger.error("Unable to parse messages: {}", e.getMessage());
        }

        return new ArrayList<>();
    }

    private String[] getExploitCommand(String exploitType, File exploitFile, String teamIp) {
        String[] commandLine = executorProperties.getCommandLine().get(exploitType).toArray(new String[0]);

        for (int i = 0; i < commandLine.length; i++) {
            commandLine[i] = commandLine[i].replaceAll("%exploit%", exploitFile.getName());
            commandLine[i] = commandLine[i].replaceAll("%team%", teamIp);
        }

        return commandLine;
    }

    @SuppressWarnings("unchecked")
    @AgentTaskHandler(taskType = "export_logs")
    void exportExecutionLog(AgentTask task) {
        Map<String, Object> parameters = task.getParameters();

        if (!parameters.containsKey("exploit") || !parameters.containsKey("team"))
            throw new IllegalArgumentException("Invalid export request");

        Map<String, Object> exploit = (Map<String, Object>) parameters.get("exploit");
        Map<String, Object> team = (Map<String, Object>) parameters.get("team");

        logger.info(String.format("Collecting execution log for '%s' (type: %s)", exploit.get("name"), exploit.get("type")));

        File outputLog = getTempFile("%s/logs/%s.output.log", exploit.get("id"), team.get("name"));
        File errorLog = getTempFile("%s/logs/%s.error.log", exploit.get("id"), team.get("name"));

        Map<String, Object> result = new LinkedHashMap<>();

        if (outputLog.exists() && outputLog.isFile()) {
            try {
                result.put("output", Files.readAllLines(outputLog.toPath()));
            } catch (IOException e) {
                logger.error("Unable to read log file: {}", outputLog.getAbsolutePath());
            }
        }
        if (errorLog.exists() && errorLog.isFile()) {
            try {
                result.put("error", Files.readAllLines(errorLog.toPath()));
            } catch (IOException e) {
                logger.error("Unable to read log file: {}", errorLog.getAbsolutePath());
            }
        }

        perimeterAgent.reportTask(task, result);
    }

    @SuppressWarnings("unchecked")
    @AgentTaskHandler(taskType = "run")
    void executeExploit(AgentTask task) {
        Map<String, Object> parameters = task.getParameters();

        if (!parameters.containsKey("exploit") || !parameters.containsKey("teams") || !parameters.containsKey("flagPattern"))
            throw new IllegalArgumentException("Invalid execution task");

        Map<String, Object> exploit = (Map<String, Object>) parameters.get("exploit");
        List<Map<String, Object>> teams = (List<Map<String, Object>>) parameters.get("teams");
        Pattern flagPattern = Pattern.compile((String) parameters.get("flagPattern"));

        if (teams.size() == 0) {
            logger.info(String.format("Skipping execution of exploit '%s': no teams registered", exploit.get("name")));
            return;
        }

        logger.info(String.format("Running exploit '%s' (type: %s)", exploit.get("name"), exploit.get("type")));

        Map<String, Object> result = new LinkedHashMap<>();

        File exploitDir = getTempFile("%s", exploit.get("id"));
        exploitDir.mkdirs();

        File exploitFile = writeExploitFile(exploit);

        getTempFile("%s/logs", exploit.get("id")).mkdirs();
        File preExecOutputLog = getTempFile("%s/logs/preexec.output.log", exploit.get("id"));
        File preExecErrorLog = getTempFile("%s/logs/preexec.error.log", exploit.get("id"));

        String exploitPreExec = (String) parameters.get("preExec");
        if (Objects.nonNull(exploitPreExec) && exploitPreExec.length() > 0) {
            int exitCode = executeAndWait(
                exploitPreExec.split("\\s"), exploitDir,
                preExecOutputLog, preExecErrorLog
            );

            if (exitCode != 0) {
                perimeterAgent.reportEvent("warning", String.format("PreExec failed for '%s'", exploit.get("name")));
                logger.warn(
                    "PreExec script for '{}' return non-zero exit code. Check logs at {}",
                    exploit.get("name"), preExecErrorLog.getAbsolutePath()
                );
            }
        }

        Map<String, Object> executionResult = new HashMap<>();

        ForkJoinPool threadPool = new ForkJoinPool(teams.size());
        try {
            threadPool.submit(() -> teams.parallelStream()
                .forEach(team -> {
                    Map<String, Object> teamExecutionResult = new HashMap<>();

                    getTempFile("%s/logs", exploit.get("id")).mkdirs();
                    File outputLog = getTempFile("%s/logs/%s.output.log", exploit.get("id"), team.get("name"));
                    File errorLog = getTempFile("%s/logs/%s.error.log", exploit.get("id"), team.get("name"));

                    int exitValue = executeAndWait(
                        getExploitCommand((String) exploit.get("type"), exploitFile, (String) team.get("ip")),
                        exploitDir, outputLog, errorLog
                    );

                    teamExecutionResult.put("exitCode", exitValue);
                    teamExecutionResult.put("flags", extractFlags(outputLog, flagPattern));
                    teamExecutionResult.put("events", extractEvents(outputLog));

                    executionResult.put((String) team.get("name"), teamExecutionResult);
                })
            ).join();
        } finally {
            threadPool.shutdown();
        }

        result.put("execution", executionResult);

        perimeterAgent.reportTask(task, result);
    }
}
