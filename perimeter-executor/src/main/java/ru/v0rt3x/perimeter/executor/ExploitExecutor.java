package ru.v0rt3x.perimeter.executor;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import ru.v0rt3x.perimeter.agent.PerimeterAgentTaskHandler;
import ru.v0rt3x.perimeter.agent.annotation.AgentTaskHandler;
import ru.v0rt3x.perimeter.agent.types.AgentTask;
import ru.v0rt3x.perimeter.executor.properties.PerimeterExecutorProperties;
import ru.v0rt3x.perimeter.executor.utils.ProcessUtils;

import javax.annotation.PostConstruct;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.util.*;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Component
public class ExploitExecutor extends PerimeterAgentTaskHandler {

    @Autowired
    private PerimeterExecutorProperties executorProperties;

    private File tmpDirectory;

    private static final Logger logger = LoggerFactory.getLogger(ExploitExecutor.class);

    private static final Pattern EVENT_PATTERN = Pattern.compile(
        "^(?<level>INFO|WARNING|URGENT)\\{(?<message>[^\\}]+)\\}$"
    );

    public ExploitExecutor() {
        super("executor");
    }

    @PostConstruct
    private void setUpExecutor() {
        tmpDirectory = executorProperties.getTmpDirectory();

        if (!tmpDirectory.exists())
            tmpDirectory.mkdirs();

        if (!tmpDirectory.isDirectory())
            throw new IllegalStateException(String.format(
                "%s is not a directory", tmpDirectory.getAbsolutePath()
            ));
    }

    private File getTempFile(String format, Object... args) {
        return new File(tmpDirectory, String.format(format, args));
    }

    private File writeExploitFile(Map<String, Object> exploit) {
        String exploitFileName = String.format(
            "exploit_%s.%s", exploit.get("id"), ((String) exploit.get("type")).toLowerCase()
        );
        File exploitFile = getTempFile(exploitFileName);

        try (FileWriter writer = new FileWriter(exploitFile)) {
            writer.write(new String(
                Base64.getDecoder().decode((String) exploit.get("script"))
            ));
        } catch (IOException e) {
            logger.error("Unable to write exploit file: {}", e.getMessage());
        }

        return exploitFile;
    }

    private int executeAndWait(String[] command, File outputLog, File errorLog) {
        ProcessBuilder processBuilder = new ProcessBuilder(command);

        processBuilder.environment().putAll(System.getenv());
        processBuilder.directory(executorProperties.getTmpDirectory());

        if (outputLog.exists())
            outputLog.delete();

        if (errorLog.exists())
            errorLog.delete();

        processBuilder.redirectOutput(ProcessBuilder.Redirect.to(outputLog));
        processBuilder.redirectError(ProcessBuilder.Redirect.to(errorLog));

        try {
            Process process = processBuilder.start();

            if (!process.waitFor(executorProperties.getExecutionTimeout(), TimeUnit.MILLISECONDS)) {
                int processId = ProcessUtils.getProcessId(process);
                ProcessUtils.kill(processId, 9);

                process.destroyForcibly().waitFor();

                logger.warn("Exploit PID{} killed by timer", processId);
            }

            return process.exitValue();
        } catch (InterruptedException | IOException e) {
            logger.error("Unable to execute command: {}", e.getMessage());
        }

        return 1;
    }

    private List<String> extractFlags(File logFile, Pattern flagPattern) {
        try {
            return Files.readAllLines(logFile.toPath()).parallelStream()
                .filter(Objects::nonNull)
                .filter(line -> flagPattern.matcher(line).matches())
                .collect(Collectors.toList());
        } catch (IOException e) {
            logger.error("Unable to parse flags: {}", e.getMessage());
        }

        return new ArrayList<>();
    }

    private List<Map<String, String>> extractEvents(File logFile) {
        try {
            return Files.readAllLines(logFile.toPath()).parallelStream()
                .filter(Objects::nonNull)
                .map(EVENT_PATTERN::matcher)
                .filter(Matcher::matches)
                .map(matcher -> {
                    Map<String, String> event = new HashMap<>();

                    event.put("level", matcher.group("level"));
                    event.put("message", matcher.group("message"));

                    return event;
                })
                .collect(Collectors.toList());
        } catch (IOException e) {
            logger.error("Unable to parse messages: {}", e.getMessage());
        }

        return new ArrayList<>();
    }

    private String getExploitCommand(String exploitType, File exploitFile) {
        String commandLine = executorProperties.getCommandLine().get(exploitType);

        return commandLine.replaceAll("%exploit%", exploitFile.getAbsolutePath());
    }

    @SuppressWarnings("unchecked")
    @AgentTaskHandler(taskType = "run")
    void executeExploit(AgentTask task) {
        Map<String, Object> parameters = task.getParameters();

        if (!parameters.containsKey("exploit") || !parameters.containsKey("teams") || !parameters.containsKey("flagPattern"))
            throw new IllegalArgumentException("Invalid execution task");

        Map<String, Object> exploit = (Map<String, Object>) parameters.get("exploit");
        List<Map<String, Object>> teams = (List<Map<String, Object>>) parameters.get("teams");
        Pattern flagPattern = Pattern.compile((String) parameters.get("flagPattern"));

        if (teams.size() == 0) {
            logger.info(String.format("Skipping execution of exploit '%s': no teams registered", exploit.get("name")));
            return;
        }

        logger.info(String.format("Running exploit '%s' (type: %s)", exploit.get("name"), exploit.get("type")));

        Map<String, Object> result = new LinkedHashMap<>();

        File exploitFile = writeExploitFile(exploit);

        File preExecOutputLog = getTempFile("%s.preexec.output.log", exploitFile.getName());
        File preExecErrorLog = getTempFile("%s.preexec.error.log", exploitFile.getName());

        String exploitPreExec = (String) parameters.get("preExec");
        if (Objects.nonNull(exploitPreExec) && exploitPreExec.length() > 0) {
            int exitCode = executeAndWait(
                exploitPreExec.split("\\s"),
                preExecOutputLog, preExecErrorLog
            );

            if (exitCode != 0) {
                perimeterAgent.reportEvent("warning", String.format("PreExec failed for '%s'", exploit.get("name")));
                logger.warn(
                    "PreExec script for '{}' return non-zero exit code. Check logs at {}",
                    exploit.get("name"), preExecErrorLog.getAbsolutePath()
                );
            }
        }

        String exploitCommand = getExploitCommand((String) exploit.get("type"), exploitFile);

        Map<String, Object> executionResult = new HashMap<>();

        ForkJoinPool threadPool = new ForkJoinPool(teams.size());
        try {
            threadPool.submit(() -> teams.parallelStream()
                .forEach(team -> {
                    Map<String, Object> teamExecutionResult = new HashMap<>();

                    File outputLog = getTempFile("%s.%s.output.log", exploitFile.getName(), team.get("name"));
                    File errorLog = getTempFile("%s.%s.error.log", exploitFile.getName(), team.get("name"));

                    int exitValue = executeAndWait(
                        exploitCommand.replaceAll("%team%", (String) team.get("ip")).split("\\s"),
                        outputLog, errorLog
                    );

                    teamExecutionResult.put("exitCode", exitValue);
                    teamExecutionResult.put("flags", extractFlags(outputLog, flagPattern));
                    teamExecutionResult.put("events", extractEvents(outputLog));

                    executionResult.put((String) team.get("name"), teamExecutionResult);
                })
            ).join();
        } finally {
            threadPool.shutdown();
        }

        result.put("execution", executionResult);

        perimeterAgent.reportTask(task, result);
    }
}
