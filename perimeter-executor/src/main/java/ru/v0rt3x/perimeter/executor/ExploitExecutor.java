package ru.v0rt3x.perimeter.executor;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import ru.v0rt3x.perimeter.agent.PerimeterAgent;
import ru.v0rt3x.perimeter.agent.types.AgentTask;
import ru.v0rt3x.perimeter.executor.properties.PerimeterExecutorProperties;

import javax.annotation.PostConstruct;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;

@Component
public class ExploitExecutor {

    @Autowired
    private PerimeterExecutorProperties executorProperties;

    @Autowired
    private PerimeterAgent perimeterAgent;

    private File tmpDirectory;
    private AgentTask task = AgentTask.noOp();

    private static final Logger logger = LoggerFactory.getLogger(ExploitExecutor.class);

    @PostConstruct
    private void registerAgent() {
        perimeterAgent.registerAgent("execute");
    }

    @PostConstruct
    private void setUpExecutor() {
        tmpDirectory = executorProperties.getTmpDirectory();

        if (!tmpDirectory.exists())
            tmpDirectory.mkdirs();

        if (!tmpDirectory.isDirectory())
            throw new IllegalStateException(String.format(
                "%s is not a directory", tmpDirectory.getAbsolutePath()
            ));
    }

    @Scheduled(fixedRate = 5000L)
    private void getTask() {
        AgentTask agentTask = perimeterAgent.getTask();

        switch (agentTask.getType()) {
            case "execute":
                this.task = agentTask;
                break;
            default:
                break;
        }
    }

    private void setExecution(Map<String, Object> parameters) {

    }

    private File getTempFile(String format, Object... args) {
        return new File(tmpDirectory, String.format(format, args));
    }

    private File writeExploitFile(Map<String, Object> exploit) {
        String exploitFileName = String.format(
            "exploit_%d.%s", exploit.get("id"), ((String) exploit.get("type")).toLowerCase()
        );
        File exploitFile = getTempFile(exploitFileName);

        try (FileWriter writer = new FileWriter(exploitFile)) {
            writer.write(new String(
                Base64.getDecoder().decode((String) exploit.get("script"))
            ));
        } catch (IOException e) {
            logger.error("Unable to write exploit file: {}", e.getMessage());
        }

        return exploitFile;
    }

    private int executeAndWait(String[] command, File outputLog, File errorLog) {
        ProcessBuilder processBuilder = new ProcessBuilder(command);

        processBuilder.environment().putAll(System.getenv());
        processBuilder.directory(executorProperties.getTmpDirectory());

        if (outputLog.exists())
            outputLog.delete();

        if (errorLog.exists())
            errorLog.delete();

        processBuilder.redirectOutput(ProcessBuilder.Redirect.to(outputLog));
        processBuilder.redirectError(ProcessBuilder.Redirect.to(errorLog));

        try {
            Process process = processBuilder.start();

            process.waitFor(executorProperties.getExecutionTimeout(), TimeUnit.MILLISECONDS);

            return process.exitValue();
        } catch (InterruptedException | IOException e) {
            logger.error("Unable to execute command: {}", e.getMessage());
        }

        return 1;
    }

    private void extractFlags(File logFile, Pattern flagPattern, List<String> target) {
        try {
            Files.readAllLines(logFile.toPath()).parallelStream()
                .filter(Objects::nonNull)
                .filter(line -> flagPattern.matcher(line).matches())
                .forEach(target::add);
        } catch (IOException e) {
            logger.error("Unable to parse flags: {}", e.getMessage());
        }
    }

    private String getExploitCommand(String exploitType, File exploitFile) {
        String commandLine = executorProperties.getCommandLine().get(exploitType);

        return commandLine.replaceAll("%exploit%", exploitFile.getAbsolutePath());
    }

    public void executeExploit() {
        if (task.getType().equals("noop"))
            return;

        Map<String, Object> parameters = task.getParameters();

        if (!parameters.containsKey("exploit") || !parameters.containsKey("teams") || !parameters.containsKey("flagPattern"))
            throw new IllegalArgumentException("Invalid execution task");

        Map<String, Object> exploit = (Map<String, Object>) parameters.get("exploit");
        List<Map<String, Object>> teams = (List<Map<String, Object>>) parameters.get("teams");
        Pattern flagPattern = Pattern.compile((String) parameters.get("flagPattern"));

        logger.info(String.format("Running exploit '%s' (type: %s)", exploit.get("name"), exploit.get("type")));

        Map<String, Object> result = new LinkedHashMap<>();

        File exploitFile = writeExploitFile(exploit);
        List<String> flags = new CopyOnWriteArrayList<>();

        File preExecOutputLog = getTempFile("%s.preexec.output.log", exploitFile.getName());
        File preExecErrorLog = getTempFile("%s.preexec.error.log", exploitFile.getName());

        String exploitPreExec = (String) result.get("preExec");
        if (Objects.nonNull(exploitPreExec) && exploitPreExec.length() > 0) {
            int exitCode = executeAndWait(
                exploitPreExec.split("\\s"),
                preExecOutputLog, preExecErrorLog
            );
        }

        String exploitCommand = getExploitCommand((String) exploit.get("type"), exploitFile);

        teams.parallelStream()
            .map(team -> (String) team.get("ip"))
            .forEach(team -> {
                File outputLog = getTempFile("%s.%s.output.log", exploitFile.getName(), team);
                File errorLog = getTempFile("%s.%s.error.log", exploitFile.getName(), team);

                int exitValue = executeAndWait(
                    exploitCommand.replaceAll("%team%", team).split("\\s"),
                    outputLog, errorLog
                );

                extractFlags(outputLog, flagPattern, flags);
            });

        result.put("flags", flags);

        perimeterAgent.reportTask(task, result);
        task = AgentTask.noOp();
    }
}
