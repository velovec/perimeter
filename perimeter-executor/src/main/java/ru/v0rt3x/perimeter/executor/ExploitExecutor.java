package ru.v0rt3x.perimeter.executor;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import ru.v0rt3x.perimeter.agent.PerimeterAgent;
import ru.v0rt3x.perimeter.agent.types.AgentTask;
import ru.v0rt3x.perimeter.executor.properties.PerimeterExecutorProperties;
import ru.v0rt3x.perimeter.executor.utils.ProcessUtils;

import javax.annotation.PostConstruct;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Component
public class ExploitExecutor {

    @Autowired
    private PerimeterExecutorProperties executorProperties;

    @Autowired
    private PerimeterAgent perimeterAgent;

    private File tmpDirectory;
    private AgentTask task = AgentTask.noOp();

    private static final Logger logger = LoggerFactory.getLogger(ExploitExecutor.class);

    @PostConstruct
    private void registerAgent() {
        perimeterAgent.registerAgent("execute");
    }

    @PostConstruct
    private void setUpExecutor() {
        tmpDirectory = executorProperties.getTmpDirectory();

        if (!tmpDirectory.exists())
            tmpDirectory.mkdirs();

        if (!tmpDirectory.isDirectory())
            throw new IllegalStateException(String.format(
                "%s is not a directory", tmpDirectory.getAbsolutePath()
            ));
    }

    @Scheduled(fixedRate = 5000L)
    private void getTask() {
        if (!"noop".equals(task.getType()))
            return;

        AgentTask agentTask = perimeterAgent.getTask();

        switch (agentTask.getType()) {
            case "execute":
                this.task = agentTask;
                break;
            default:
                break;
        }
    }

    private File getTempFile(String format, Object... args) {
        return new File(tmpDirectory, String.format(format, args));
    }

    private File writeExploitFile(Map<String, Object> exploit) {
        String exploitFileName = String.format(
            "exploit_%s.%s", exploit.get("id"), ((String) exploit.get("type")).toLowerCase()
        );
        File exploitFile = getTempFile(exploitFileName);

        try (FileWriter writer = new FileWriter(exploitFile)) {
            writer.write(new String(
                Base64.getDecoder().decode((String) exploit.get("script"))
            ));
        } catch (IOException e) {
            logger.error("Unable to write exploit file: {}", e.getMessage());
        }

        return exploitFile;
    }

    private int executeAndWait(String[] command, File outputLog, File errorLog) {
        ProcessBuilder processBuilder = new ProcessBuilder(command);

        processBuilder.environment().putAll(System.getenv());
        processBuilder.directory(executorProperties.getTmpDirectory());

        if (outputLog.exists())
            outputLog.delete();

        if (errorLog.exists())
            errorLog.delete();

        processBuilder.redirectOutput(ProcessBuilder.Redirect.to(outputLog));
        processBuilder.redirectError(ProcessBuilder.Redirect.to(errorLog));

        try {
            Process process = processBuilder.start();

            if (!process.waitFor(executorProperties.getExecutionTimeout(), TimeUnit.MILLISECONDS)) {
                int processId = ProcessUtils.getProcessId(process);
                ProcessUtils.kill(processId, 9);

                process.destroyForcibly().waitFor();

                logger.warn("Exploit PID{} killed by timer", processId);
            }

            return process.exitValue();
        } catch (InterruptedException | IOException e) {
            logger.error("Unable to execute command: {}", e.getMessage());
        }

        return 1;
    }


    private List<String> extractFlags(File logFile, Pattern flagPattern) {
        try {
            return Files.readAllLines(logFile.toPath()).parallelStream()
                .filter(Objects::nonNull)
                .filter(line -> flagPattern.matcher(line).matches())
                .collect(Collectors.toList());
        } catch (IOException e) {
            logger.error("Unable to parse flags: {}", e.getMessage());
        }

        return new ArrayList<>();
    }

    private String getExploitCommand(String exploitType, File exploitFile) {
        String commandLine = executorProperties.getCommandLine().get(exploitType);

        return commandLine.replaceAll("%exploit%", exploitFile.getAbsolutePath());
    }

    @SuppressWarnings("unchecked")
    @Scheduled(fixedDelay = 5000L)
    void executeExploit() {
        if (task.getType().equals("noop"))
            return;

        Map<String, Object> parameters = task.getParameters();

        if (!parameters.containsKey("exploit") || !parameters.containsKey("teams") || !parameters.containsKey("flagPattern"))
            throw new IllegalArgumentException("Invalid execution task");

        Map<String, Object> exploit = (Map<String, Object>) parameters.get("exploit");
        List<Map<String, Object>> teams = (List<Map<String, Object>>) parameters.get("teams");
        Pattern flagPattern = Pattern.compile((String) parameters.get("flagPattern"));

        logger.info(String.format("Running exploit '%s' (type: %s)", exploit.get("name"), exploit.get("type")));

        Map<String, Object> result = new LinkedHashMap<>();

        File exploitFile = writeExploitFile(exploit);

        File preExecOutputLog = getTempFile("%s.preexec.output.log", exploitFile.getName());
        File preExecErrorLog = getTempFile("%s.preexec.error.log", exploitFile.getName());

        String exploitPreExec = (String) result.get("preExec");
        if (Objects.nonNull(exploitPreExec) && exploitPreExec.length() > 0) {
            int exitCode = executeAndWait(
                exploitPreExec.split("\\s"),
                preExecOutputLog, preExecErrorLog
            );

            if (exitCode != 0) {
                logger.warn(
                    "PreExec script for '{}' return non-zero exit code. Check logs at {}",
                    exploit.get("name"), preExecErrorLog.getAbsolutePath()
                );
            }
        }

        String exploitCommand = getExploitCommand((String) exploit.get("type"), exploitFile);

        Map<String, Object> executionResult = new HashMap<>();

        teams.parallelStream()
            .forEach(team -> {
                Map<String, Object> teamExecutionResult = new HashMap<>();

                File outputLog = getTempFile("%s.%s.output.log", exploitFile.getName(), team.get("name"));
                File errorLog = getTempFile("%s.%s.error.log", exploitFile.getName(), team.get("name"));

                int exitValue = executeAndWait(
                    exploitCommand.replaceAll("%team%", (String) team.get("ip")).split("\\s"),
                    outputLog, errorLog
                );

                teamExecutionResult.put("exitCode", exitValue);
                teamExecutionResult.put("flags", extractFlags(outputLog, flagPattern));

                executionResult.put((String) team.get("name"), teamExecutionResult);
            });

        result.put("execution", executionResult);

        perimeterAgent.reportTask(task, result);
        task = AgentTask.noOp();
    }
}
