package ru.v0rt3x.perimeter.server.exploit.command;

import ru.v0rt3x.perimeter.server.exploit.ExploitManager;
import ru.v0rt3x.perimeter.server.exploit.dao.Exploit;
import ru.v0rt3x.perimeter.server.exploit.dao.ExploitExecutionResult;
import ru.v0rt3x.perimeter.server.flag.dao.FlagPriority;
import ru.v0rt3x.perimeter.server.shell.PerimeterShellCommand;
import ru.v0rt3x.perimeter.server.shell.annotations.CommandAction;
import ru.v0rt3x.perimeter.server.shell.annotations.ShellCommand;
import ru.v0rt3x.perimeter.server.shell.command.exception.NotImplementedException;
import ru.v0rt3x.perimeter.server.shell.console.Table;

import java.io.IOException;
import java.util.Base64;
import java.util.Objects;

@ShellCommand(command = "exploit", description = "Manage exploits")
public class ExploitCommand extends PerimeterShellCommand  {

    private ExploitManager exploitManager;

    @Override
    protected void init() throws IOException {
        exploitManager = context.getBean(ExploitManager.class);
    }

    @Override
    protected void execute() throws IOException {
        throw new NotImplementedException();
    }

    @CommandAction("List registered exploits")
    public void list() throws IOException {
        Table exploits = new Table("Name", "Type", "Priority", "Hits");

        for (Exploit exploit: exploitManager.listExploits()) {
            if (!exploit.isDisabled()) {
                exploits.addRow(
                    exploit.getName(), exploit.getType(), exploit.getPriority().name(), String.valueOf(exploit.getHits())
                );
            } else {
                exploits.addRow(
                    exploit.getName(), exploit.getType(), exploit.getPriority().name(), String.valueOf(exploit.getHits())
                );
            }
        }

        console.write(exploits);
    }

    @CommandAction("Show exploit script")
    public void show() throws IOException {
        if (args.size() < 1) {
            console.error("exploit show <name>");
            exit(1);
            return;
        }

        Exploit exploit = exploitManager.getExploit(args.get(0));
        if (Objects.nonNull(exploit) && !exploit.isDisabled()) {
            Table script = new Table("#", "Script");

            int num = 1;
            for (String line: new String(Base64.getDecoder().decode(exploit.getScript())).split("\\r?\\n")) {
                script.addRow(String.valueOf(num++), "'" + line.replaceFirst("\\s++$", "") + "'");
            }

            console.write(script);
        } else {
            console.error("Unable to find exploit '%s'", args.get(0));
            exit(1);
        }
    }

    @CommandAction("Execute exploit")
    public void exec() throws IOException {
        if (args.size() < 1) {
            console.error("exploit exec <name>");
            exit(1);
            return;
        }

        Exploit exploit = exploitManager.getExploit(args.get(0));
        if (Objects.nonNull(exploit) && !exploit.isDisabled()) {
            exploitManager.scheduleExploitExecution(exploit);
            console.writeLine("Exploit execution scheduled");
        } else {
            console.error("Unable to find exploit '%s'", args.get(0));
            exit(1);
        }
    }

    @CommandAction("Set exploit priority")
    public void set_priority() throws IOException {
        if (args.size() < 2) {
            console.error("exploit set_priority <name> <priority>");
            exit(1);
            return;
        }

        Exploit exploit = exploitManager.getExploit(args.get(0));
        if (Objects.nonNull(exploit) && !exploit.isDisabled()) {
            exploit.setPriority(FlagPriority.valueOf(args.get(1).toUpperCase()));
            console.writeLine("Exploit priority set to %s", exploit.getPriority());
            exploitManager.updateExploit(exploit);
        } else {
            console.error("Unable to find exploit '%s'", args.get(0));
            exit(1);
        }
    }

    @CommandAction("Set pre-exec command for exploit")
    public void set_preexec() throws IOException {
        if (args.size() < 1) {
            console.error("exploit set_preexec <name> [<command>]");
            exit(1);
            return;
        }

        Exploit exploit = exploitManager.getExploit(args.get(0));
        if (Objects.nonNull(exploit) && !exploit.isDisabled()) {
            if (args.size() > 1) {
                exploit.setPreExec(String.join(" ", args.subList(1, args.size())));
            } else {
                exploit.setPreExec(null);
            }
            exploitManager.updateExploit(exploit);
            console.writeLine("Exploit updated");
        } else {
            console.error("Unable to find exploit '%s'", args.get(0));
            exit(1);
        }
    }

    @CommandAction("Delete exploit")
    public void delete() throws IOException {
        if (args.size() < 1) {
            console.error("exploit delete <name>");
            exit(1);
            return;
        }

        Exploit exploit = exploitManager.getExploit(args.get(0));
        if (Objects.nonNull(exploit)) {
            exploitManager.deleteExploit(exploit);
            console.writeLine("Exploit deleted");
        } else {
            console.error("Unable to find exploit '%s'", args.get(0));
            exit(1);
        }
    }

    @CommandAction("Enable exploit scheduled execution")
    public void enable() throws IOException {
        if (exploitManager.isExecutionEnabled()) {
            console.writeLine("Already enabled");
        } else {
            exploitManager.setExecutionEnabled(true);
            console.writeLine("Scheduled execution enabled");
        }
    }

    @CommandAction("Disable exploit scheduled execution")
    public void disable() throws IOException {
        if (!exploitManager.isExecutionEnabled()) {
            console.writeLine("Already disabled");
        } else {
            exploitManager.setExecutionEnabled(false);
            console.writeLine("Scheduled execution disabled");
        }
    }

    @CommandAction("Show exploit execution stats")
    public void stats() throws IOException {
        if (args.size() < 1) {
            console.error("exploit stats <name>");
            exit(1);
            return;
        }

        Exploit exploit = exploitManager.getExploit(args.get(0));
        if (Objects.nonNull(exploit) && !exploit.isDisabled()) {
            Table executionStats = new Table("Team", "Hits", "Last Exit Code");

            for (ExploitExecutionResult result: exploitManager.getExploitExecutionResults(exploit)) {
                executionStats.addRow(result.getTeam(), result.getHits(), result.getExitCode());
            }

            console.write(executionStats);
        } else {
            console.error("Unable to find exploit '%s'", args.get(0));
            exit(1);
        }
    }

    @Override
    protected void onInterrupt() {

    }
}
