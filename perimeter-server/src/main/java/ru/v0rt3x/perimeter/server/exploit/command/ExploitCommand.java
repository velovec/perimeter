package ru.v0rt3x.perimeter.server.exploit.command;

import ru.v0rt3x.perimeter.server.exploit.ExploitManager;
import ru.v0rt3x.perimeter.server.exploit.dao.Exploit;
import ru.v0rt3x.perimeter.server.exploit.dao.ExploitExecutionResult;
import ru.v0rt3x.perimeter.server.flag.dao.FlagPriority;
import ru.v0rt3x.perimeter.server.shell.PerimeterShellCommand;
import ru.v0rt3x.perimeter.server.shell.annotations.CommandAction;
import ru.v0rt3x.perimeter.server.shell.annotations.ShellCommand;
import ru.v0rt3x.perimeter.server.shell.command.exception.NotImplementedException;
import ru.v0rt3x.perimeter.server.team.TeamManager;
import ru.v0rt3x.perimeter.server.team.dao.Team;
import ru.v0rt3x.perimeter.server.utils.HexBin;
import ru.v0rt3x.shell.console.Table;

import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import java.util.List;
import java.util.Objects;

@ShellCommand(command = "exploit", description = "Manage exploits")
public class ExploitCommand extends PerimeterShellCommand  {

    private ExploitManager exploitManager;
    private TeamManager teamManager;

    private List<String> output;
    private List<String> error;
    private boolean waiting = false;

    private static final long EXPORT_TIMEOUT = 20000L;

    @Override
    protected void init() throws IOException {
        exploitManager = context.getBean(ExploitManager.class);
        teamManager = context.getBean(TeamManager.class);
    }

    @Override
    protected void execute() throws IOException {
        throw new NotImplementedException();
    }

    @CommandAction("List registered exploits")
    public void list() throws IOException {
        Table exploits = new Table("Name", "Type", "Priority", "Hits");

        for (Exploit exploit: exploitManager.listExploits()) {
            if (!exploit.isDisabled()) {
                exploits.addRow(
                    exploit.getName(), exploit.getType(), exploit.getPriority().name(), String.valueOf(exploit.getHits())
                );
            } else {
                exploits.addRow(
                    exploit.getName(), exploit.getType(), exploit.getPriority().name(), String.valueOf(exploit.getHits())
                );
            }
        }

        console.write(exploits);
    }

    @CommandAction("Show exploit script")
    public void show() throws IOException {
        if (args.size() < 1) {
            console.error("exploit show <name>");
            exit(1);
            return;
        }

        Exploit exploit = exploitManager.getExploit(args.get(0));
        if (Objects.nonNull(exploit) && !exploit.isDisabled()) {
            Table script = new Table("#", "Script");

            int num = 1;
            String scriptContent = new String(Base64.getDecoder().decode(exploit.getScript()));
            for (String line: scriptContent.split("\\r?\\n")) {
                script.addRow(String.valueOf(num++), "'" + line.replaceFirst("\\s++$", "") + "'");
            }

            try {
                MessageDigest md = MessageDigest.getInstance("MD5");

                md.update(scriptContent.getBytes());

                script.addRow("Checksum", HexBin.encode(md.digest()));
            } catch (NoSuchAlgorithmException e) {
                logger.error("Unable to get MD5 checksum: {}", e.getMessage());
            }

            console.write(script);
        } else {
            console.error("Unable to find exploit '%s'", args.get(0));
            exit(1);
        }
    }

    @CommandAction("Execute exploit")
    public void exec() throws IOException {
        if (args.size() < 1) {
            console.error("exploit exec [--force true] <name>");
            exit(1);
            return;
        }

        Exploit exploit = exploitManager.getExploit(args.get(0));
        if (Objects.nonNull(exploit) && !exploit.isDisabled()) {
            exploitManager.scheduleExploitExecution(exploit, Boolean.parseBoolean(kwargs.getOrDefault("force", "false")));
            console.writeLine("Exploit execution scheduled");
        } else {
            console.error("Unable to find exploit '%s'", args.get(0));
            exit(1);
        }
    }

    @CommandAction("Set exploit priority")
    public void set_priority() throws IOException {
        if (args.size() < 2) {
            console.error("exploit set_priority <name> <priority>");
            exit(1);
            return;
        }

        Exploit exploit = exploitManager.getExploit(args.get(0));
        if (Objects.nonNull(exploit) && !exploit.isDisabled()) {
            exploit.setPriority(FlagPriority.valueOf(args.get(1).toUpperCase()));
            console.writeLine("Exploit priority set to %s", exploit.getPriority());
            exploitManager.updateExploit(exploit);
        } else {
            console.error("Unable to find exploit '%s'", args.get(0));
            exit(1);
        }
    }

    @CommandAction("Set pre-exec command for exploit")
    public void set_preexec() throws IOException {
        if (args.size() < 1) {
            console.error("exploit set_preexec <name> [<command>]");
            exit(1);
            return;
        }

        Exploit exploit = exploitManager.getExploit(args.get(0));
        if (Objects.nonNull(exploit) && !exploit.isDisabled()) {
            if (args.size() > 1) {
                exploit.setPreExec(String.join(" ", args.subList(1, args.size())));
            } else {
                exploit.setPreExec(null);
            }
            exploitManager.updateExploit(exploit);
            console.writeLine("Exploit updated");
        } else {
            console.error("Unable to find exploit '%s'", args.get(0));
            exit(1);
        }
    }

    @CommandAction("Delete exploit")
    public void delete() throws IOException {
        if (args.size() < 1) {
            console.error("exploit delete <name>");
            exit(1);
            return;
        }

        Exploit exploit = exploitManager.getExploit(args.get(0));
        if (Objects.nonNull(exploit)) {
            exploitManager.deleteExploit(exploit);
            console.writeLine("Exploit deleted");
        } else {
            console.error("Unable to find exploit '%s'", args.get(0));
            exit(1);
        }
    }

    @CommandAction("Enable exploit scheduled execution")
    public void enable() throws IOException {
        if (exploitManager.isExecutionEnabled()) {
            console.writeLine("Already enabled");
        } else {
            exploitManager.setExecutionEnabled(true);
            console.writeLine("Scheduled execution enabled");
        }
    }

    @CommandAction("Disable exploit scheduled execution")
    public void disable() throws IOException {
        if (!exploitManager.isExecutionEnabled()) {
            console.writeLine("Already disabled");
        } else {
            exploitManager.setExecutionEnabled(false);
            console.writeLine("Scheduled execution disabled");
        }
    }

    @CommandAction("Show exploit execution stats")
    public void stats() throws IOException {
        if (args.size() < 1) {
            console.error("exploit stats <name>");
            exit(1);
            return;
        }

        Exploit exploit = exploitManager.getExploit(args.get(0));
        if (Objects.nonNull(exploit) && !exploit.isDisabled()) {
            Table executionStats = new Table("Team", "Hits", "Last Exit Code");

            for (ExploitExecutionResult result: exploitManager.getExploitExecutionResults(exploit)) {
                executionStats.addRow(result.getTeam(), result.getHits(), result.getExitCode());
            }

            console.write(executionStats);
        } else {
            console.error("Unable to find exploit '%s'", args.get(0));
            exit(1);
        }
    }

    @CommandAction("Get execution logs")
    public void logs() throws IOException {
        if (args.size() < 2) {
            console.error("exploit logs <name> <team>");
            exit(1);
            return;
        }

        Exploit exploit = exploitManager.getExploit(args.get(0));
        if (Objects.nonNull(exploit) && !exploit.isDisabled()) {
            Team team = teamManager.getTeam(args.get(1));
            if (Objects.nonNull(team)) {
                requestLogs(exploit, team);
            } else {
                console.error("Unable to find team '%s'", args.get(1));
                exit(1);
            }
        } else {
            console.error("Unable to find exploit '%s'", args.get(0));
            exit(1);
        }
    }

    private void requestLogs(Exploit exploit, Team team) throws IOException {
        waiting = true;

        exploitManager.requestLogs(exploit, team, (output, error) -> {
            this.waiting = false;

            this.output = output;
            this.error = error;
        });

        long time = System.currentTimeMillis();
        while (waiting && Math.abs(time - System.currentTimeMillis()) <= EXPORT_TIMEOUT) {
            sleep(100L);
        }

        if (Objects.isNull(output) && Objects.isNull(error)) {
            console.write("No logs found");
        } else {
            if (Objects.nonNull(output)) {
                console.write(new Table(output, "Output Log"));
            }

            if (Objects.nonNull(error)) {
                console.write(new Table(error, "Error Log"));
            }
        }
    }

    @Override
    protected void onInterrupt() {

    }
}
