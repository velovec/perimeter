package ru.v0rt3x.perimeter.server.exploit;

import io.micrometer.core.instrument.Metrics;
import io.micrometer.core.instrument.Tags;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import ru.v0rt3x.perimeter.server.agent.AgentManager;
import ru.v0rt3x.perimeter.server.agent.AgentTask;
import ru.v0rt3x.perimeter.server.event.EventManager;
import ru.v0rt3x.perimeter.server.event.dao.EventType;
import ru.v0rt3x.perimeter.server.exploit.dao.Exploit;
import ru.v0rt3x.perimeter.server.exploit.dao.ExploitExecutionResult;
import ru.v0rt3x.perimeter.server.exploit.dao.ExploitExecutionResultRepository;
import ru.v0rt3x.perimeter.server.exploit.dao.ExploitRepository;
import ru.v0rt3x.perimeter.server.files.FileRouter;
import ru.v0rt3x.perimeter.server.flag.FlagProcessor;
import ru.v0rt3x.perimeter.server.flag.dao.Flag;
import ru.v0rt3x.perimeter.server.flag.dao.FlagPriority;
import ru.v0rt3x.perimeter.server.team.dao.Team;
import ru.v0rt3x.perimeter.server.team.dao.TeamRepository;

import javax.annotation.PostConstruct;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Component
public class ExploitManager {

    @Autowired
    private AgentManager agentManager;

    @Autowired
    private ExploitRepository exploitRepository;

    @Autowired
    private TeamRepository teamRepository;

    @Autowired
    private FileRouter fileRouter;

    @Autowired
    private ExploitExecutionResultRepository executionResultRepository;

    @Autowired
    private FlagProcessor flagProcessor;

    @Autowired
    private EventManager eventManager;

    private boolean executionEnabled = true;

    private static final Logger logger = LoggerFactory.getLogger(ExploitManager.class);

    @PostConstruct
    public void setUpExploitManager() {
        fileRouter.addRoute("exploits", Pattern.compile(
            "^exploits/(?<type>[^/]+)/(?<name>.*?)$"
        ), this::processExploit);

        executionResultRepository.findAll()
            .forEach(this::buildMetric);

        agentManager.registerReportHandler("executor", "run", this::processExploitExecutionReport);
    }

    private void processExploit(String author, Matcher pathMatcher, byte[] data) {
        String type = pathMatcher.group("type");
        String name = pathMatcher.group("name");

        Exploit exploit = exploitRepository.findByName(name);

        if (Objects.isNull(exploit)) {
            exploit = new Exploit();

            exploit.setName(name);
            exploit.setType(type);
            exploit.setScript(new String(Base64.getEncoder().encode(data)));
            exploit.setPriority(FlagPriority.LOW);
            exploit.setDisabled(false);

            exploitRepository.save(exploit);
            logger.info("User '{}' registered exploit '{}' (type: {})", author, name, type);
            eventManager.createEvent("%s: Exploit added by '%s' (type: %s)", name, author, type);
        } else {
            exploit.setScript(new String(Base64.getEncoder().encode(data)));
            exploit.setType(type);
            exploit.setDisabled(false);
            exploit.setUpdated(true);

            exploitRepository.save(exploit);
            logger.info("User '{}' updated exploit '{}' (type: {})", author, name, type);
            eventManager.createEvent("%s: Exploit updated by '%s' (type: %s)", name, author, type);
        }
    }

    @Scheduled(fixedRateString = "${perimeter.exploit.execution-interval}")
    private void scheduleExploitsExecution() {
        if (executionEnabled) {
            agentManager.clearTaskQueue("execute");

            exploitRepository.findAll().parallelStream()
                .filter(exploit -> !exploit.isDisabled() && !exploit.isUpdated())
                .forEach(exploit -> scheduleExploitExecution(exploit, false));

            exploitRepository.findAll().parallelStream()
                .filter(Exploit::isUpdated)
                .forEach(exploit -> scheduleExploitExecution(exploit, true));
        }
    }

    public void scheduleExploitExecution(Exploit exploit, boolean force) {
        Map<String, Object> parameters = new LinkedHashMap<>();

        parameters.put("exploit", exploit);
        parameters.put("flagPattern", flagProcessor.getFlagPattern().pattern());

        List<Team> teams = new ArrayList<>();
        for (Team team: teamRepository.findAllByActive(true)) {
            ExploitExecutionResult result = executionResultRepository.findByExploitAndTeam(exploit, team.getName());

            if (force || Objects.isNull(result) || (result.getExitCode() != 68)) {
                teams.add(team);
            }
        }
        parameters.put("teams", teams);

        if (teams.size() > 0) {
            exploit.setDisabled(false);
            eventManager.createEvent("%s: execution scheduled (type: %s)", exploit.getName(), exploit.getType());

            agentManager.queueTask("executor", "run", parameters);
        } else {
            exploit.setDisabled(true);
            eventManager.createEvent("%s: execution skipped (type: %s)", exploit.getName(), exploit.getType());
        }

        exploitRepository.save(exploit);
    }

    @SuppressWarnings("unchecked")
    public void processExploitExecutionReport(String agentType, String taskType, Map<String, Object> parameters, Map<String, Object> result) {
        if (!result.containsKey("execution") || !parameters.containsKey("exploit"))
            return;

        Map<String, Object> exploitData = (Map<String, Object>) parameters.get("exploit");
        Map<String, Object> execution = (Map<String, Object>) result.get("execution");

        Exploit exploit = exploitRepository.findById((Integer) exploitData.get("id"));

        if (Objects.isNull(exploit))  {
            logger.warn("Got flags from unregistered exploit");
            return;
        }

        for (String team: execution.keySet()) {
            ExploitExecutionResult executionResult = executionResultRepository.findByExploitAndTeam(exploit, team);

            if (Objects.isNull(executionResult)) {
                executionResult = new ExploitExecutionResult();

                executionResult.setExploit(exploit);
                executionResult.setTeam(team);
                executionResult.setHits(0);
            }

            Map<String, Object> teamExecution = (Map<String, Object>) execution.get(team);

            int hits = ((List<String>) teamExecution.get("flags")).parallelStream()
                .filter(Objects::nonNull)
                .map(flag -> Flag.newFlag(flag, exploit.getPriority()))
                .map(flagProcessor::addFlag)
                .mapToInt(x -> x ? 1 : 0)
                .sum();

            ((List<Map<String, String>>) teamExecution.get("events"))
                .forEach(event -> {
                    String message = String.format("%s: %s", exploit.getName(), event.get("message"));
                    EventType level = EventType.valueOf(event.get("level"));

                    eventManager.createEvent(level, message);
                });

            executionResult.setHits(executionResult.getHits() + hits);
            executionResult.setExitCode((Integer) teamExecution.get("exitCode"));

            switch (executionResult.getExitCode()) {
                case 0:
                    break;
                case 68:
                    eventManager.createEvent(EventType.WARNING, "%s: Team '%s' is no longer vulnerable", exploit.getName(), team);
                    break;
                case 126:
                    eventManager.createEvent(EventType.WARNING, "%s: Internal error: command invoked cannot execute", exploit.getName());
                    break;
                case 127:
                    eventManager.createEvent(EventType.WARNING, "%s: Internal error: command not found", exploit.getName());
                    break;
                case 128:
                    eventManager.createEvent(EventType.WARNING, "%s: Internal error: invalid argument to exit", exploit.getName());
                    break;
                case 129:
                case 130:
                case 131:
                case 132:
                case 133:
                case 134:
                case 135:
                case 136:
                case 137:
                    eventManager.createEvent(EventType.WARNING, "%s: Exploit for '%s' was killed (signal: %d)", exploit.getName(), team, executionResult.getExitCode() - 128);
                    break;
                default:
                    eventManager.createEvent(EventType.WARNING, "%s: Failed to attack '%s' (exit code: %d)", exploit.getName(), team, executionResult.getExitCode());
                    break;
            }

            exploit.setHits(exploit.getHits() + hits);

            buildMetric(executionResult);
            executionResultRepository.save(executionResult);
        }

        exploit.setUpdated(false);
        exploitRepository.save(exploit);
    }

    public List<Exploit> listExploits() {
        return Collections.unmodifiableList(exploitRepository.findAll());
    }

    public Exploit getExploit(String name) {
        return exploitRepository.findByName(name);
    }

    public void updateExploit(Exploit exploit) {
        exploitRepository.save(exploit);
    }

    public void deleteExploit(Exploit exploit) {
        exploit.setDisabled(true);

        exploitRepository.save(exploit);
    }

    public boolean isExecutionEnabled() {
        return executionEnabled;
    }

    public void setExecutionEnabled(boolean enabled) {
        this.executionEnabled = enabled;
    }

    public List<ExploitExecutionResult> getExploitExecutionResults(Exploit exploit) {
        return executionResultRepository.findAllByExploit(exploit);
    }

    public void buildMetric(ExploitExecutionResult result) {
        Tags tags = Tags.of(
            "exploit", result.getExploit().getName(),
            "team", result.getTeam()
        );

        Metrics.gauge(
            "exploit_hits", tags, executionResultRepository,
            (r) -> {
                ExploitExecutionResult res = r.findByExploitAndTeam(result.getExploit(), result.getTeam());

                return Objects.nonNull(res) ? res.getHits() : 0;
            }
        );
    }

    public void clearStats() {
        for (ExploitExecutionResult result: executionResultRepository.findAll()) {
            result.setHits(0);

            executionResultRepository.save(result);
        }

    }
}
