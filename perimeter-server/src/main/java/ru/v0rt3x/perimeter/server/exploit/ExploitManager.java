package ru.v0rt3x.perimeter.server.exploit;

import io.micrometer.core.instrument.Metrics;
import io.micrometer.core.instrument.Tags;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import ru.v0rt3x.perimeter.server.agent.AgentManager;
import ru.v0rt3x.perimeter.server.agent.AgentTask;
import ru.v0rt3x.perimeter.server.event.EventManager;
import ru.v0rt3x.perimeter.server.exploit.dao.Exploit;
import ru.v0rt3x.perimeter.server.exploit.dao.ExploitExecutionResult;
import ru.v0rt3x.perimeter.server.exploit.dao.ExploitExecutionResultRepository;
import ru.v0rt3x.perimeter.server.exploit.dao.ExploitRepository;
import ru.v0rt3x.perimeter.server.files.FileRouter;
import ru.v0rt3x.perimeter.server.flag.FlagProcessor;
import ru.v0rt3x.perimeter.server.flag.dao.FlagPriority;
import ru.v0rt3x.perimeter.server.team.dao.Team;
import ru.v0rt3x.perimeter.server.team.dao.TeamRepository;

import javax.annotation.PostConstruct;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Component
public class ExploitManager {

    @Autowired
    private AgentManager agentManager;

    @Autowired
    private ExploitRepository exploitRepository;

    @Autowired
    private TeamRepository teamRepository;

    @Autowired
    private FileRouter fileRouter;

    @Autowired
    private ExploitExecutionResultRepository executionResultRepository;

    @Autowired
    private FlagProcessor flagProcessor;

    @Autowired
    private EventManager eventManager;

    private boolean executionEnabled = true;

    private static final Logger logger = LoggerFactory.getLogger(ExploitManager.class);

    @PostConstruct
    public void setUpExploitManager() {
        fileRouter.addRoute("exploits", Pattern.compile(
            "^exploits/(?<type>[^/]+)/(?<name>.*?)$"
        ), this::processExploit);

        executionResultRepository.findAll()
            .forEach(this::buildMetric);
    }

    private void processExploit(String author, Matcher pathMatcher, byte[] data) {
        String type = pathMatcher.group("type");
        String name = pathMatcher.group("name");

        Exploit exploit = exploitRepository.findByName(name);

        if (Objects.isNull(exploit)) {
            exploit = new Exploit();

            exploit.setName(name);
            exploit.setType(type);
            exploit.setScript(new String(Base64.getEncoder().encode(data)));
            exploit.setPriority(FlagPriority.LOW);
            exploit.setDisabled(false);

            exploitRepository.save(exploit);
            logger.info("User '{}' registered exploit '{}' (type: {})", author, name, type);
            eventManager.createEvent("%s: Exploit added by '%s' (type: %s)", name, author, type);
        } else {
            exploit.setScript(new String(Base64.getEncoder().encode(data)));
            exploit.setType(type);
            exploit.setDisabled(false);
            exploit.setUpdated(true);

            exploitRepository.save(exploit);
            logger.info("User '{}' updated exploit '{}' (type: {})", author, name, type);
            eventManager.createEvent("%s: Exploit updated by '%s' (type: %s)", name, author, type);
        }
    }

    @Scheduled(fixedRateString = "${perimeter.exploit.execution-interval}")
    private void scheduleExploitsExecution() {
        if (executionEnabled) {
            agentManager.clearTaskQueue("execute");

            exploitRepository.findAll().parallelStream()
                .filter(exploit -> !exploit.isDisabled() && !exploit.isUpdated())
                .forEach(exploit -> scheduleExploitExecution(exploit, false));

            exploitRepository.findAll().parallelStream()
                .filter(Exploit::isUpdated)
                .forEach(exploit -> scheduleExploitExecution(exploit, true));
        }
    }

    public void scheduleExploitExecution(Exploit exploit, boolean force) {
        Map<String, Object> parameters = new LinkedHashMap<>();

        parameters.put("exploit", exploit);
        parameters.put("flagPattern", flagProcessor.getFlagPattern().pattern());

        List<Team> teams = new ArrayList<>();
        for (Team team: teamRepository.findAllByActive(true)) {
            ExploitExecutionResult result = executionResultRepository.findByExploitAndTeam(exploit, team.getName());

            if (force || Objects.isNull(result) || (result.getExitCode() != 68)) {
                teams.add(team);
            }
        }
        parameters.put("teams", teams);

        if (teams.size() > 0) {
            exploit.setDisabled(false);
            eventManager.createEvent("%s: execution scheduled (type: %s)", exploit.getName(), exploit.getType());

            agentManager.queueTask("execute", parameters);
        } else {
            exploit.setDisabled(true);
            eventManager.createEvent("%s: execution skipped (type: %s)", exploit.getName(), exploit.getType());
        }

        exploitRepository.save(exploit);
    }

    public List<Exploit> listExploits() {
        return Collections.unmodifiableList(exploitRepository.findAll());
    }

    public Exploit getExploit(String name) {
        return exploitRepository.findByName(name);
    }

    public void updateExploit(Exploit exploit) {
        exploitRepository.save(exploit);
    }

    public void deleteExploit(Exploit exploit) {
        exploit.setDisabled(true);

        exploitRepository.save(exploit);
    }

    public boolean isExecutionEnabled() {
        return executionEnabled;
    }

    public void setExecutionEnabled(boolean enabled) {
        this.executionEnabled = enabled;
    }

    public List<ExploitExecutionResult> getExploitExecutionResults(Exploit exploit) {
        return executionResultRepository.findAllByExploit(exploit);
    }

    public void buildMetric(ExploitExecutionResult result) {
        Tags tags = Tags.of(
            "exploit", result.getExploit().getName(),
            "team", result.getTeam()
        );

        Metrics.gauge(
            "exploit_hits", tags, executionResultRepository,
            (r) -> {
                ExploitExecutionResult res = r.findByExploitAndTeam(result.getExploit(), result.getTeam());

                return Objects.nonNull(res) ? res.getHits() : 0;
            }
        );
    }

    public void clearStats() {
        for (ExploitExecutionResult result: executionResultRepository.findAll()) {
            result.setHits(0);

            executionResultRepository.save(result);
        }

    }
}
