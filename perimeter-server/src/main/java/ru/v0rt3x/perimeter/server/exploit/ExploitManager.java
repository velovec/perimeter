package ru.v0rt3x.perimeter.server.exploit;

import io.micrometer.core.instrument.Metrics;
import io.micrometer.core.instrument.Tags;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import ru.v0rt3x.perimeter.server.agent.AgentManager;
import ru.v0rt3x.perimeter.server.agent.AgentTask;
import ru.v0rt3x.perimeter.server.event.EventManager;
import ru.v0rt3x.perimeter.server.exploit.dao.Exploit;
import ru.v0rt3x.perimeter.server.exploit.dao.ExploitExecutionResult;
import ru.v0rt3x.perimeter.server.exploit.dao.ExploitExecutionResultRepository;
import ru.v0rt3x.perimeter.server.exploit.dao.ExploitRepository;
import ru.v0rt3x.perimeter.server.files.FileRouter;
import ru.v0rt3x.perimeter.server.flag.FlagProcessor;
import ru.v0rt3x.perimeter.server.flag.dao.FlagPriority;
import ru.v0rt3x.perimeter.server.properties.PerimeterProperties;
import ru.v0rt3x.perimeter.server.team.dao.TeamRepository;

import javax.annotation.PostConstruct;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Component
public class ExploitManager {

    @Autowired
    private AgentManager agentManager;

    @Autowired
    private ExploitRepository exploitRepository;

    @Autowired
    private PerimeterProperties perimeterProperties;

    @Autowired
    private TeamRepository teamRepository;

    @Autowired
    private FileRouter fileRouter;

    @Autowired
    private ExploitExecutionResultRepository executionResultRepository;

    @Autowired
    private FlagProcessor flagProcessor;

    @Autowired
    private EventManager eventManager;

    private boolean executionEnabled = true;

    private static final Logger logger = LoggerFactory.getLogger(ExploitManager.class);

    @PostConstruct
    public void setUpExploitManager() {
        fileRouter.addRoute("exploits", Pattern.compile(
            "^exploits/(?<type>[^/]+)/(?<name>.*?)$"
        ), this::processExploit);

        executionResultRepository.findAll()
            .forEach(this::buildMetric);
    }

    private void processExploit(String author, Matcher pathMatcher, byte[] data) {
        String type = pathMatcher.group("type");
        String name = pathMatcher.group("name");

        Exploit exploit = exploitRepository.findByName(name);

        if (Objects.isNull(exploit)) {
            exploit = new Exploit();

            exploit.setName(name);
            exploit.setType(type);
            exploit.setScript(new String(Base64.getEncoder().encode(data)));
            exploit.setPriority(FlagPriority.LOW);
            exploit.setDisabled(false);

            exploitRepository.save(exploit);
            logger.info("User '{}' registered exploit '{}' (type: {})", author, name, type);
            eventManager.createEvent("User '%s' added exploit '%s' (type: %s)", author, name, type);
        } else {
            exploit.setScript(new String(Base64.getEncoder().encode(data)));
            exploit.setType(type);
            exploit.setDisabled(false);

            exploitRepository.save(exploit);
            logger.info("User '{}' updated exploit '{}' (type: {})", author, name, type);
            eventManager.createEvent("User '%s' updated exploit '%s' (type: %s)", author, name, type);
        }
    }

    @Scheduled(fixedRateString = "${perimeter.exploit.execution-interval}")
    private void scheduleExploitsExecution() {
        if (executionEnabled) {
            agentManager.clearTaskQueue("execute");

            exploitRepository.findAll().parallelStream()
                .filter(exploit -> !exploit.isDisabled())
                .forEach(this::scheduleExploitExecution);
        }
    }

    public void scheduleExploitExecution(Exploit exploit) {
        AgentTask executionTask = new AgentTask();
        Map<String, Object> parameters = new LinkedHashMap<>();

        parameters.put("exploit", exploit);
        parameters.put("flagPattern", flagProcessor.getFlagPattern().pattern());

        parameters.put("teams", teamRepository.findAllByActive(true));

        executionTask.setType("execute");
        executionTask.setParameters(parameters);

        eventManager.createEvent("Exploit '%s' (type: %s) execution scheduled", exploit.getName(), exploit.getType());

        agentManager.queueTask(executionTask);
    }

    public List<Exploit> listExploits() {
        return Collections.unmodifiableList(exploitRepository.findAll());
    }

    public Exploit getExploit(String name) {
        return exploitRepository.findByName(name);
    }

    public void updateExploit(Exploit exploit) {
        exploitRepository.save(exploit);
    }

    public void deleteExploit(Exploit exploit) {
        exploit.setDisabled(true);

        exploitRepository.save(exploit);
    }

    public boolean isExecutionEnabled() {
        return executionEnabled;
    }

    public void setExecutionEnabled(boolean enabled) {
        this.executionEnabled = enabled;
    }

    public List<ExploitExecutionResult> getExploitExecutionResults(Exploit exploit) {
        return executionResultRepository.findAllByExploit(exploit);
    }

    public void buildMetric(ExploitExecutionResult result) {
        Tags tags = Tags.of(
            "exploit", result.getExploit().getName(),
            "team", result.getTeam()
        );

        Metrics.gauge(
            "exploit_hits", tags, executionResultRepository,
            (r) -> {
                ExploitExecutionResult res = r.findByExploitAndTeam(result.getExploit(), result.getTeam());

                return Objects.nonNull(res) ? res.getHits() : 0;
            }
        );
    }

    public void clearStats() {
        for (ExploitExecutionResult result: executionResultRepository.findAll()) {
            result.setHits(0);

            executionResultRepository.save(result);
        }

    }
}
