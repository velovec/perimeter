package ru.v0rt3x.perimeter.server.exploit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import ru.v0rt3x.perimeter.server.agent.AgentManager;
import ru.v0rt3x.perimeter.server.agent.AgentTask;
import ru.v0rt3x.perimeter.server.exploit.dao.Exploit;
import ru.v0rt3x.perimeter.server.exploit.dao.ExploitExecutionResult;
import ru.v0rt3x.perimeter.server.exploit.dao.ExploitExecutionResultRepository;
import ru.v0rt3x.perimeter.server.exploit.dao.ExploitRepository;
import ru.v0rt3x.perimeter.server.files.FileRouter;
import ru.v0rt3x.perimeter.server.flag.dao.FlagPriority;
import ru.v0rt3x.perimeter.server.properties.PerimeterProperties;
import ru.v0rt3x.perimeter.server.team.dao.TeamRepository;

import javax.annotation.PostConstruct;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Component
public class ExploitManager {

    @Autowired
    private AgentManager agentManager;

    @Autowired
    private ExploitRepository exploitRepository;

    @Autowired
    private PerimeterProperties perimeterProperties;

    @Autowired
    private TeamRepository teamRepository;

    @Autowired
    private FileRouter fileRouter;

    @Autowired
    private ExploitExecutionResultRepository executionResultRepository;

    private boolean executionEnabled = true;

    private static final Logger logger = LoggerFactory.getLogger(ExploitManager.class);

    @PostConstruct
    public void setUpExploitManager() {
        fileRouter.addRoute("exploits", Pattern.compile(
            "^exploits/(?<type>[^/]+)/(?<name>.*?)$"
        ), this::processExploit);
    }

    private void processExploit(String author, Matcher pathMatcher, byte[] data) {
        String type = pathMatcher.group("type");
        String name = pathMatcher.group("name");

        Exploit exploit = exploitRepository.findByName(name);

        if (Objects.isNull(exploit)) {
            exploit = new Exploit();

            exploit.setName(name);
            exploit.setType(type);
            exploit.setScript(new String(Base64.getEncoder().encode(data)));
            exploit.setPriority(FlagPriority.LOW);

            exploitRepository.save(exploit);
            logger.info("User '{}' registered exploit '{}' (type: {})", author, name, type);
        } else {
            exploit.setScript(new String(Base64.getEncoder().encode(data)));

            exploitRepository.save(exploit);
            logger.info("User '{}' updated exploit '{}' (type: {})", author, name, type);
        }
    }

    @Scheduled(fixedRateString = "${perimeter.exploit.execution-interval}")
    private void scheduleExploitsExecution() {
        if (executionEnabled) {
            agentManager.clearTaskQueue("execute");

            exploitRepository.findAll().parallelStream()
                .forEach(this::scheduleExploitExecution);
        }
    }

    public void scheduleExploitExecution(Exploit exploit) {
        AgentTask executionTask = new AgentTask();
        Map<String, Object> parameters = new LinkedHashMap<>();

        parameters.put("exploit", exploit);

        if (perimeterProperties.getFlag().getJwt().isEnabled()) {
            parameters.put("flagPattern", perimeterProperties.getFlag().getJwt().getPattern().pattern());
        } else {
            parameters.put("flagPattern", perimeterProperties.getFlag().getPattern().pattern());
        }

        parameters.put("teams", teamRepository.findAllByActive(true));

        executionTask.setType("execute");
        executionTask.setParameters(parameters);

        agentManager.queueTask(executionTask);
    }

    public List<Exploit> listExploits() {
        return Collections.unmodifiableList(exploitRepository.findAll());
    }

    public Exploit getExploit(String name) {
        return exploitRepository.findByName(name);
    }

    public void updateExploit(Exploit exploit) {
        exploitRepository.save(exploit);
    }

    public void deleteExploit(Exploit exploit) {
        exploitRepository.delete(exploit);
    }

    public boolean isExecutionEnabled() {
        return executionEnabled;
    }

    public void setExecutionEnabled(boolean enabled) {
        this.executionEnabled = enabled;
    }

    public List<ExploitExecutionResult> getExploitExecutionResults(Exploit exploit) {
        return executionResultRepository.findAllByExploit(exploit);
    }
}
